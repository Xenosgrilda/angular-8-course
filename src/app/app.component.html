<div class="container">

  <h1 style="text-align: center; margin-top: 30px;">Template Driven Form</h1>
  <form (ngSubmit)="onSubmit(f)" #f="ngForm">

    <!-- userData Group-->
    <div class="row" ngModelGroup="userData" #userData="ngModelGroup">
      <div class="six columns">
        <label for="username">Username</label>
        <input ngModel required
               name="username" class="u-full-width" type="text" placeholder="John..." id="username">
        <button type="button">Suggest Username</button>
      </div>

      <div class="six columns">
        <label for="email">Email</label>
        <input ngModel required email #emailEl="ngModel"
               name="email" class="u-full-width" type="email" placeholder="someguy@somth.com" id="email">
        <p *ngIf="emailEl.touched && emailEl.invalid" class="form-error">
          Please... You know how to write an email, right?</p>
      </div>

      <p class="form-error" *ngIf="userData.invalid && userData.touched">The User data group is invalid.</p>
    </div>

    <div class="row">

      <div class="six columns">
        <label for="answer">Question Answer</label>
        <textarea [(ngModel)]="answer" required name="answer" class="u-full-width" id="answer"></textarea>
        <h6>Your answer: </h6>
        <p>{{answer}}</p>
      </div>

      <div class="six columns">
        <label for="secret">Secret Question</label>
        <select [ngModel]="defaultSecretSelect" name="secret" class="u-full-width" id="secret">
          <option value="pet">Your first Pet?</option>
          <option value="teacher">Your first teacher?</option>
          <option value="car">Color of your car?</option>
        </select>
      </div>

    </div>

    <input
      [disabled]="f.invalid"
      [className]="f.invalid ? 'button' : 'button-primary'"
      class="u-pull-right" type="submit" value="Submit">
  </form>

</div>
<!-- NgMODEL
 To register which input we want to have mapped, we just need to add the ngModel directive!
    ngModel

 To be able to retrieve the Submit action via Angular we can attach the (ngSubmit) to the <form> Element.
-->

<!--
  To retrieve the form data object that Angular has made, we need to do a peculiar thing, add a template reference to
  the form and assign to it to "ngForm". This will capture the object exposed by this form element which is a directive,
  when we add FormsModule.
    (ngSubmit)="onSubmit(f)" #f="ngForm"
-->

<!-- VALIDATIONS
  Since we're using a Template Driven approach, our validations should be on template...
  We can use HTML validators, and they will act as selectors for Directives built in Angular.

  Angular also provides some additional directives such as "email" (used above).
  If validation don't pass Angular will update the form value and also each form controller. It'll also add classes to
  those controllers.
 -->

<!--
  Here we're disabling the 'submit' <button> if the form 'f' (which we have access to the form object provided by
  FormsModule) has any error.

  Also, since Angular add some classes depending on the control state (invalid = ngInvalid, touched = ngTouched) we can
  take advantage on that and add styling

  And if we wanted to get a specific input? In the same way angular expose the form information as a template reference:
    #f="ngForm"

  We can do the same with a control(input), but for that, we don't want to expose the whole form just the control
  element, to do so:
    <input ngModel required email #emailEl="ngModel"
           name="email" class="u-full-width" type="email" placeholder="someguy@somth.com" id="email">
    <p *ngIf="emailEl.touched && emailEl.invalid" class="form-error">...</p>
-->

<!-- PROPERTY BINDINGS
  Property Binding (One-Way Data Binding)
    What if we wanted to assign a value to our controls. We could ngModel, but in another way.
      [ngModel]="variable";
    this will update the control value with the variable's value. With that we have a one-way property binding.

  Two-Wau Data Binding
    suppose we wanted the user to provide an answer to its secret question, and for some reason, repeat it to the user.
    for that we can use the traditional Two-Way dataBinding
      [(ngModel)]
    which is a shorter form of:
      [ngModel]="overRideRate" (ngModelChange)="overRideRate = $event"
-->

<!-- GROUPING FIELDS/CONTROLS/DATA
  To group controls, or put them under a property like:

    userData: {
      name: ...,
      email: ...,
      secret: ...
    }

   We can make use of another NgForms directive, the "ngModuleGroup". To do so in TD, just need to place it into a
   parent of those controls.
   We can also get a JS Reference to the Group Object in the same way we do for ngForm or ngModule:

    #userDataRef="ngModelGroup"
-->
